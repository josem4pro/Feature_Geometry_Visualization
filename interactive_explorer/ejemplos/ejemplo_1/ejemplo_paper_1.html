<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ejemplo 1: Trayectoria de "The quick brown fox..."</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        .header { text-align: center; margin-bottom: 30px; }
        h1 { color: #4fc3f7; font-size: 2em; margin-bottom: 10px; }
        h2 { color: #4fc3f7; font-size: 1.4em; margin: 30px 0 15px 0; }
        .subtitle { color: #90a4ae; font-size: 1.1em; }

        .container { max-width: 1200px; margin: 0 auto; }

        .sentence-display {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            border: 2px solid #4fc3f7;
        }
        .sentence-text {
            font-size: 1.5em;
            color: #fff;
            font-style: italic;
        }

        .explanation {
            background: rgba(79, 195, 247, 0.1);
            border-left: 4px solid #4fc3f7;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 12px 12px 0;
            line-height: 1.6;
        }
        .explanation h3 { color: #4fc3f7; margin: 0 0 10px 0; }

        .viz-container {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .viz-title { color: #4fc3f7; font-size: 1.2em; margin-bottom: 10px; }
        .viz-desc { color: #90a4ae; font-size: 0.95em; margin-bottom: 15px; }

        #trajectory-3d, #tokens-3d {
            width: 100%;
            height: 500px;
            border-radius: 8px;
            background: #0d1117;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin: 15px 0;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .layer-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .layer-card {
            background: rgba(0,0,0,0.3);
            padding: 10px 15px;
            border-radius: 8px;
            text-align: center;
            border-left: 3px solid;
        }
        .layer-card.embedding { border-color: #4CAF50; }
        .layer-card.early { border-color: #2196F3; }
        .layer-card.middle { border-color: #FF9800; }
        .layer-card.late { border-color: #f44336; }
        .layer-num { font-size: 0.8em; color: #90a4ae; }
        .layer-name { font-weight: bold; color: #fff; }

        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .token-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }
        .token-chip {
            padding: 8px 16px;
            border-radius: 20px;
            font-family: monospace;
            font-size: 1em;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        .controls button {
            padding: 10px 20px;
            background: #4fc3f7;
            border: none;
            border-radius: 6px;
            color: #1a1a2e;
            font-weight: bold;
            cursor: pointer;
        }
        .controls button:hover { background: #81d4fa; }
        .controls button.active { background: #ff9800; }

        .nav-links {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .nav-links a {
            color: #4fc3f7;
            text-decoration: none;
            margin: 0 15px;
        }
        .nav-links a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Ejemplo 1: Trayectoria a traves de las Capas</h1>
            <p class="subtitle">Como GPT-2 procesa una frase, capa por capa</p>
        </div>

        <div class="sentence-display">
            <div class="sentence-text">"The quick brown fox jumps over the lazy dog"</div>
        </div>

        <div class="explanation">
            <h3>Que muestra esta visualizacion?</h3>
            <p>
                Cuando GPT-2 procesa esta frase, la representacion interna <strong>cambia en cada capa</strong>.
                Cada punto en el grafico 3D representa el estado de la frase completa en una capa especifica.
            </p>
            <p>
                La <strong>trayectoria</strong> conecta estos puntos, mostrando como el "pensamiento" del modelo
                evoluciona desde la entrada (embedding) hasta la salida (capa 12).
            </p>
        </div>

        <div class="viz-container">
            <div class="viz-title">Trayectoria por Capas (13 puntos)</div>
            <div class="viz-desc">
                Cada punto = promedio de todos los tokens en esa capa.
                La linea muestra la evolucion del procesamiento.
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Inicio (Embedding)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    <span>Capas tempranas (1-4)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF9800;"></div>
                    <span>Capas intermedias (5-8)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>Capas finales (9-12)</span>
                </div>
            </div>
            <div id="trajectory-3d"></div>
            <div class="controls">
                <button id="btn-rotate" class="active">Auto-rotar</button>
                <button id="btn-reset">Reset vista</button>
            </div>
        </div>

        <h2>Etapas del Procesamiento</h2>
        <div class="layer-info">
            <div class="layer-card embedding">
                <div class="layer-num">Capa 0</div>
                <div class="layer-name">Embedding</div>
                <div style="font-size: 0.8em; color: #90a4ae;">Tokens → Vectores</div>
            </div>
            <div class="layer-card early">
                <div class="layer-num">Capas 1-4</div>
                <div class="layer-name">Sintaxis</div>
                <div style="font-size: 0.8em; color: #90a4ae;">Estructura gramatical</div>
            </div>
            <div class="layer-card middle">
                <div class="layer-num">Capas 5-8</div>
                <div class="layer-name">Semantica</div>
                <div style="font-size: 0.8em; color: #90a4ae;">Significado contextual</div>
            </div>
            <div class="layer-card late">
                <div class="layer-num">Capas 9-12</div>
                <div class="layer-name">Prediccion</div>
                <div style="font-size: 0.8em; color: #90a4ae;">Siguiente token</div>
            </div>
        </div>

        <div class="viz-container">
            <div class="viz-title">Posicion de cada Token (Capa Final)</div>
            <div class="viz-desc">
                Donde termina cada token en el espacio latente despues de pasar por todas las capas.
            </div>
            <div class="token-list">
                <span class="token-chip" style="background: #e91e63; color: white;">The</span>
                <span class="token-chip" style="background: #9c27b0; color: white;">quick</span>
                <span class="token-chip" style="background: #673ab7; color: white;">brown</span>
                <span class="token-chip" style="background: #3f51b5; color: white;">fox</span>
                <span class="token-chip" style="background: #2196f3; color: white;">jumps</span>
                <span class="token-chip" style="background: #00bcd4; color: white;">over</span>
                <span class="token-chip" style="background: #009688; color: white;">the</span>
                <span class="token-chip" style="background: #4caf50; color: white;">lazy</span>
                <span class="token-chip" style="background: #8bc34a; color: white;">dog</span>
            </div>
            <div id="tokens-3d"></div>
            <div class="controls">
                <button id="btn-rotate-tokens" class="active">Auto-rotar</button>
                <button id="btn-reset-tokens">Reset vista</button>
            </div>
        </div>

        <div class="explanation">
            <h3>Que aprendemos de esto?</h3>
            <p>
                <strong>1. El procesamiento no es lineal:</strong> La trayectoria hace "saltos" entre capas,
                especialmente entre las capas 2-3 donde el modelo pasa de procesamiento lexico a semantico.
            </p>
            <p>
                <strong>2. Las capas tienen roles:</strong> Las primeras capas procesan sintaxis,
                las intermedias integran significado, las finales preparan la prediccion.
            </p>
            <p>
                <strong>3. El contexto importa:</strong> Cada token termina en una posicion diferente,
                influenciado por todos los demas tokens de la frase.
            </p>
        </div>

        <div class="nav-links">
            <a href="../ejemplo_2/ejemplo_paper_2.html">→ Ejemplo 2: Comparacion Fox vs Dog</a>
            <a href="../../visualizacion_completa.html">← Volver al Explorador</a>
        </div>
    </div>

    <script>
        // Data from fox_trajectory_data.json (embedded for simplicity)
        const trajectoryData = [
            {x: -264.33, y: -38.0, z: 21.8, layer: 0, name: "Embedding"},
            {x: -231.49, y: -37.06, z: 32.24, layer: 1, name: "Layer 1"},
            {x: -216.6, y: -45.14, z: 26.15, layer: 2, name: "Layer 2"},
            {x: 40.03, y: -26.98, z: -23.12, layer: 3, name: "Layer 3"},
            {x: 62.0, y: -25.72, z: -26.48, layer: 4, name: "Layer 4"},
            {x: 82.96, y: -23.33, z: -28.68, layer: 5, name: "Layer 5"},
            {x: 97.83, y: -19.53, z: -27.47, layer: 6, name: "Layer 6"},
            {x: 110.58, y: -15.19, z: -21.41, layer: 7, name: "Layer 7"},
            {x: 123.61, y: -8.08, z: -10.56, layer: 8, name: "Layer 8"},
            {x: 136.54, y: 1.86, z: 4.57, layer: 9, name: "Layer 9"},
            {x: 152.63, y: 17.72, z: 26.83, layer: 10, name: "Layer 10"},
            {x: 191.15, y: 83.28, z: 64.65, layer: 11, name: "Layer 11"},
            {x: -282.78, y: 135.44, z: -43.0, layer: 12, name: "Layer 12"}
        ];

        const tokenData = [
            {x: -112.2, y: -13.28, z: -11.95, token: "The", color: 0xe91e63},
            {x: -36.04, y: 9.38, z: 5.35, token: "quick", color: 0x9c27b0},
            {x: -22.44, y: 23.93, z: 9.31, token: "brown", color: 0x673ab7},
            {x: 25.05, y: 32.49, z: 3.56, token: "fox", color: 0x3f51b5},
            {x: 84.24, y: -16.06, z: -15.73, token: "jumps", color: 0x2196f3},
            {x: -0.41, y: -28.21, z: -0.74, token: "over", color: 0x00bcd4},
            {x: 28.17, y: -23.32, z: 11.8, token: "the", color: 0x009688},
            {x: 14.14, y: -5.06, z: 8.64, token: "lazy", color: 0x4caf50},
            {x: 17.36, y: 11.29, z: -16.66, token: "dog", color: 0x8bc34a}
        ];

        // Normalize data to fit in view
        function normalizeData(data) {
            const allX = data.map(d => d.x);
            const allY = data.map(d => d.y);
            const allZ = data.map(d => d.z);

            const minX = Math.min(...allX), maxX = Math.max(...allX);
            const minY = Math.min(...allY), maxY = Math.max(...allY);
            const minZ = Math.min(...allZ), maxZ = Math.max(...allZ);

            const range = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
            const scale = 4 / range;

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;

            return data.map(d => ({
                ...d,
                nx: (d.x - centerX) * scale,
                ny: (d.y - centerY) * scale,
                nz: (d.z - centerZ) * scale
            }));
        }

        const normTrajectory = normalizeData(trajectoryData);
        const normTokens = normalizeData(tokenData);

        // Color function for layers
        function getLayerColor(layer) {
            if (layer === 0) return 0x4CAF50;  // Green - embedding
            if (layer <= 4) return 0x2196F3;   // Blue - early
            if (layer <= 8) return 0xFF9800;   // Orange - middle
            return 0xf44336;                    // Red - late
        }

        // Setup trajectory visualization
        function setupTrajectoryViz() {
            const container = document.getElementById('trajectory-3d');
            const width = container.clientWidth;
            const height = container.clientHeight;

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d1117);

            const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            camera.position.set(5, 3, 5);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Add axes
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);

            // Add grid
            const gridHelper = new THREE.GridHelper(6, 10, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Create trajectory line
            const lineGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            normTrajectory.forEach((point, i) => {
                positions.push(point.nx, point.ny, point.nz);
                const color = new THREE.Color(getLayerColor(point.layer));
                colors.push(color.r, color.g, color.b);
            });

            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            lineGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const lineMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: 2
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);

            // Add spheres at each layer point
            normTrajectory.forEach((point, i) => {
                const geometry = new THREE.SphereGeometry(0.12, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: getLayerColor(point.layer) });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(point.nx, point.ny, point.nz);
                scene.add(sphere);
            });

            // Start/end markers
            const startGeom = new THREE.SphereGeometry(0.2, 16, 16);
            const startMat = new THREE.MeshBasicMaterial({ color: 0x4CAF50 });
            const startSphere = new THREE.Mesh(startGeom, startMat);
            startSphere.position.set(normTrajectory[0].nx, normTrajectory[0].ny, normTrajectory[0].nz);
            scene.add(startSphere);

            const endGeom = new THREE.SphereGeometry(0.2, 16, 16);
            const endMat = new THREE.MeshBasicMaterial({ color: 0xf44336 });
            const endSphere = new THREE.Mesh(endGeom, endMat);
            const last = normTrajectory[normTrajectory.length - 1];
            endSphere.position.set(last.nx, last.ny, last.nz);
            scene.add(endSphere);

            let autoRotate = true;

            document.getElementById('btn-rotate').addEventListener('click', function() {
                autoRotate = !autoRotate;
                this.classList.toggle('active', autoRotate);
            });

            document.getElementById('btn-reset').addEventListener('click', function() {
                camera.position.set(5, 3, 5);
                camera.lookAt(0, 0, 0);
                controls.reset();
            });

            function animate() {
                requestAnimationFrame(animate);
                if (autoRotate) {
                    scene.rotation.y += 0.003;
                }
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            });
        }

        // Setup token visualization
        function setupTokenViz() {
            const container = document.getElementById('tokens-3d');
            const width = container.clientWidth;
            const height = container.clientHeight;

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d1117);

            const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            camera.position.set(4, 2, 4);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Add grid
            const gridHelper = new THREE.GridHelper(4, 8, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Add token spheres
            normTokens.forEach((token, i) => {
                const geometry = new THREE.SphereGeometry(0.15, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: token.color });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(token.nx, token.ny, token.nz);
                scene.add(sphere);
            });

            // Connect tokens with line
            const lineGeometry = new THREE.BufferGeometry();
            const positions = [];
            normTokens.forEach(token => {
                positions.push(token.nx, token.ny, token.nz);
            });
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 1 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);

            let autoRotateTokens = true;

            document.getElementById('btn-rotate-tokens').addEventListener('click', function() {
                autoRotateTokens = !autoRotateTokens;
                this.classList.toggle('active', autoRotateTokens);
            });

            document.getElementById('btn-reset-tokens').addEventListener('click', function() {
                camera.position.set(4, 2, 4);
                camera.lookAt(0, 0, 0);
                controls.reset();
            });

            function animate() {
                requestAnimationFrame(animate);
                if (autoRotateTokens) {
                    scene.rotation.y += 0.002;
                }
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            });
        }

        // Initialize
        setupTrajectoryViz();
        setupTokenViz();
    </script>
</body>
</html>
